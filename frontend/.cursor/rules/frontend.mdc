---
description: rules for frontend development
globs:
alwaysApply: true
---

# code style

- NEVER EVER add comments to code. The only exceptions are you can add a docstring
  to a function or module. Otherwise, NO COMMENTS.

- use *kebab-case* for Typescript file names

- if error info needs to be returned to the calling function, just throw an
  appropriate error. do not return an object with error info. This rule does not
  apply to server actions, which can return error info in the response.

# project planning

- when starting on a medium to large sized change, first write a markdown
  project plan into the folder .cursor/projects/, and ask for review

- as you work, update the project plan and mark tasks as complete

- only work on one phase of a project at a time. always ask before continuing to
  the next phase

- include testing plans in the project plan

# components

- ALWAYS use frontend components from /components/ui when possible

- if a shadcn ui component is not available in /components/ui, install it with
  `npx shadcn@latest add component-name`

- ALWAYS use lucide-react for icons if possible

# testing - MANDATORY STEP

- 🚨 CRITICAL: IMMEDIATELY run `npm test` after ANY code changes, especially:
  - After implementing new features
  - After editing existing code
  - After making UI changes
  - Before marking any task as complete

- Tests are REQUIRED to pass before considering work done
- Use test results to guide development progress
- Never bypass tests with NODE_ENV checks

- WORKFLOW: Code → Test → Fix → Test → Complete
- If you forget to run tests, the task is NOT complete

# conventions

- use server actions instead of api routes in next.js

- do not show error messages with internal information to users. Show a generic
  error message and console.error() the details

- for toast messages, call sonner directly

# database and deployment

- create and modify sql schemas in /db/schema. Do not edit
  `/supabase/migrations/` -- this is autogenerated

# tips on frontend development to move faster

no nextjs forms: API is too limited & annoying
  * exception: when using a nice library like react-forms
* nextjs react server functions, i.e. “use server” i.e. `actions/`:
  * use only as RPCs; no formData, nor prevState
  * only call them from client components
    * on the server, error handling has to be done with error boundaries because it will blow up rendering the HTML output
  * standardize error handling technique
    * nextjs docs say the action exception will bubble to error.tsx / Suspense boundary, but I don’t want that because I don’t want to think about it
    * don’t use `redirect()` or `notFound()` in server actions
    * use try/catch within an action to log useful backend error messages
    * use try/catch on the client to generate meaningful error UX, e.g. show a toast
    * SPECIAL NOTE: if you call a server function in a `startTransition()` block, react re‑enters the render pipeline, so an uncaught throw *will* be captured by the nearest error boundary. Make sure to try {} catch {}, or just don’t do that.
  * generally just call Supabase from the client, not an action
  * For low latency needs, call the DB directly in an action
  * Name action files, put them in actions/ directories
  * interact with non-supabase services, e.g. redis
  * More than 3 seconds of work: call inngest & return info on the task
* no graphql: PITA. Use Postgrest/supabase
  * Supabase SDK over HTTP still faster than graphql
* server components:
  * only for “chrome” and static content
  * for dynamic content, use front-end SWR
  * understanding nextjs caching is too annoying, and most of the time I want a frontend cache of the data anyway. SWR also gives nice revalidation options
  * if you have to do something asynchronous in a server component, remember that caching and error handling are weird, so avoid!
* use SWR
  * Call Supabase in the SWR query
* What’s the standard client side way to write a mutation function?
  * `const handleChange => asyncMutationFunction()`. Put the mutation function next to the data loading, maybe in a shared `useMyLogic` hook.
* remember how to use `startTransition`, `useMemo`, `memo`, and `use` and not get distracted by them:
  * `startTransition`
    > Use startTransition (or its hook sibling useTransition) when you’re about to trigger an update whose result can appear a little later without breaking the user’s workflow. Think of it as telling React, “This is important, but if the browser is busy, feel free to delay or abort it so the interface stays responsive.”
    * contrast this with changes that need to happen immediately, e.g. updating the state of a controlled `input` as the user types
    * `useTransition` gives you an `isPending` value to show a placeholder/spinner/etc
    * SPECIAL NOTE: if you call a server function in a `startTransition()` block, react re‑enters the render pipeline, so an uncaught throw *will* be captured by the nearest error boundary. Make sure to try {} catch {}, or just don’t do that.
* use zod
* use inngest
* use zustand
